//**************************************************************************************************
//                         Copyright (C) 2009 RCZI
//--------------------------------------------------------------------------------------------------
// FILENAME....... drv_rnd.cpp
// DATE CREATED... 05/10/2009
// LAST MODIFIED.. 21/12/2009
// DRIVER VERSION. 1.0
//--------------------------------------------------------------------------------------------------
//	Содержимое папки: /dev/
//				..
//	<FILE>		rnd		
//--------------------------------------------------------------------------------------------------
//							Д Р А Й В Е Р    Г С Ч
//-------------------------------------------------------------------------------------------------
// !: arch: tms320c64xx
// !: sarc: all
//
// !: codepage: cp1251 
//
// !: d: Драйвер ГСЧ.<br>
// !: md: Устройство (файл) ГСЧ в ОС связан с собственным файлом rnd. 
// !: md: Путь к устройству: "/dev/rnd". Драйвер реализует стандартный 
// !: md: интерфейс взаимодействия пользователя с устройством по средствам 
// !: md: потокового чтения из устройства (файла).
// !: -:
//***sss********************************************************************************************
#include	<rts.h>
#include	<mem_fpga.iface15.h>
#include	<drv_rnd.h>

#define RND_REDY		(REG_DEVICE_STATUS & 0x8)

int32 test_rnd_random(int32 channel);
//**************************************************************************************************
//       Открытие потока
//-------------------------------------------------------------------------------------------------
// !: fn: int32 rnd_open(s_os_driver_descriptor* d, uint16 access) 
//
// !: d: Функция открывает поток на чтение.<br><br>
//
// !: d: Входные аргументы:<br>
// !: d: - *d - указатель на дескриптор драйвера, формируемый ОС;<br>
// !: d: - access - спецификатор доступа. Поддерживаемые значения: DRV_RD.<br><br>
//
// !: d: Возвращаемые значения:<br>
// !: d: - OSE_OK - если спецификатор доступа поддерживается;<br>
// !: d: - OSE_CANT_OPEN - если спецификатор доступа не поддерживается.<br>
// !: -:
//***sss********************************************************************************************
int32 rnd_open(s_os_driver_descriptor* d, uint16 access)
{
	if(access == DRV_RD){
		d->access = DRV_RD | DRV_OPENED;
		return OSE_OK;
	}
	return OSE_CANT_OPEN;
}
//**************************************************************************************************
//       Закрытие потока
//-------------------------------------------------------------------------------------------------
// !: fn: int32 rnd_close(s_os_driver_descriptor* d)
//
// !: d: Функция закрывает открытый поток на чтение.<br><br>
//
// !: d: Входные аргументы:<br>
// !: d: - *d - указатель на дескриптор драйвера, формируемый ОС.<br><br>
//
// !: d: Возвращаемые значения:<br>
// !: d: - OSE_OK - если поток на чтение был открыт;<br>
// !: d: - OSE_STREAM_NOT_OPENED - если поток на чтение не был открыт.<br>
// !: -:
//***sss********************************************************************************************
int32 rnd_close(s_os_driver_descriptor* d)
{
	if(d->access & DRV_OPENED){
		d->access = 0;
		return	OSE_OK;
	}
	return OSE_STREAM_NOT_OPENED;
}
//**************************************************************************************************
//       Чтение из потока
//-------------------------------------------------------------------------------------------------
// !: fn: int32 rnd_read(s_os_driver_descriptor* d, void* buf, int32 length)
//
// !: d: Функция осуществляет не блокирующее потоковое чтение из устройства.<br><br> 
//
// !: d: Входные аргументы:<br>
// !: d: - *d - указатель на дескриптор драйвера, формируемый ОС;<br>
// !: d: - *buf - указатель на буфер ввода;<br>
// !: d: - length - вычитываемая длинна.<br><br>
//
// !: d: Возвращаемые значения:<br>
// !: d: - Количество прочитанных байт.<br>
// !: -:
//***sss********************************************************************************************
int32 rnd_read(s_os_driver_descriptor* d, void* buf, int32 length)
{
	uint8*	recast_buf = (uint8*) buf;
	uint16	rnd_value;
	if(d->access == DRV_RD | DRV_OPENED)
	{
		for(int32 i=0; i<length; i++)
		{
			while(!RND_REDY);
			rnd_value = REG_RND_NUMBER;
			REG_RND_RESET = 0x1;
			recast_buf[i] = (rnd_value>>8)^(rnd_value);
		}
		return length;
	}
	return OSE_PERMISSION_DENIED;
}
//**************************************************************************************************
//       Запись в поток
//-------------------------------------------------------------------------------------------------
// !: fn: int32 rnd_write(s_os_driver_descriptor* d, const void* buf, int32 length)
//
// !: d: Функция драйвером не поддерживаеться.<br> 
// !: -:
//***sss********************************************************************************************
int32 rnd_write(s_os_driver_descriptor* d, const void* buf, int32 length)
{
	return OSE_PERMISSION_DENIED;
}
//**************************************************************************************************
//       Управление вводом/выводом
//--------------------------------------------------------------------------------------------------
// !: fn: int32 rnd_ioctl(s_os_driver_descriptor* d, int32 cmd, const void* arg)
//
// !: d: Функция реализует управляющее воздействие на устройство
// !: d: в соответствии с поданной командой.<br><br> 
//
// !: d: Входные аргументы:<br>
// !: d: - d - указатель на дескриптор драйвера, формируемый ОС;<br>
// !: d: - cmd - команды управления;<br>
// !: d: - arg - аргумент.<br><br>
//
// !: d: Возвращаемые значения:<br>
// !: d: - Стандартные коды ошибок ioctl.<br><br>
//
// !: d: Стандартные команды управления:<br>
// !: d: - IOC_INIT, IOC_DEINIT, IOC_INIT_DESCRIPTOR, IOC_DEINIT_DESCRIPTOR,
// !: d:   IOC_INODE_SELECT, IOC_RESIZE.<br>
//***sss********************************************************************************************
int32 rnd_ioctl(s_os_driver_descriptor* d, int32 cmd, const void* arg)
{
	switch(cmd)
	{
	//===============================================================
	//Standard control command:
		//Инициализация:
		case IOC_INIT:
        {
          register int32 error;
          for(int32 channel=0; channel<2; channel++)
          {
            for(int32 i=0; i<3; i++)
            {
              error = test_rnd_random(channel);
              if(error == OSE_OK) break;
            }
            if(error != OSE_OK) return error;
          }
          return error;
        }
		//Деинициализация:
		case IOC_DEINIT: 			
		//Инициализация данных:
		case IOC_INIT_DESCRIPTOR:		
		//Деинициализация данных:
		case IOC_DEINIT_DESCRIPTOR:	
		//Удаление данных из потока:
		case IOC_RESIZE:			
		break;

		//Переход по директориям в корне драйвера:
		case IOC_INODE_SELECT:		
		{	
			const char* recast_arg = (const char*) arg;
			if(d->access & DRV_OPENED) 
				return OSE_STREAM_OPENED;
			if(!strcmp(recast_arg,"."))
				break;
			else
			if(!strcmp(recast_arg,".."))
			{
				drv_dec(d);
				drv_rfs(d);
			}
			else
				return	OSE_NO_NODE;
		}
		break;

		default:
			return OSE_BAD_CMD;
	}
	
	return OSE_OK;
}		
//**************************************************************************************************
//       Добавить драйвер в систему
//-------------------------------------------------------------------------------------------------
// !: fn: int32 drv_rnd_plug()
//
// !: d: Добавляет драйвер ГСЧ в систему<br><br> 
//
// !: d: Возвращаемые значения:<br>
// !: d: - Стандартные коды ошибок ioctl.<br>
//***sss********************************************************************************************
int32 drv_rnd_plug()
{
  return drv_plug("/dev/rnd", INOT_FILE, &rnd_open, &rnd_close, &rnd_read, &rnd_write, &rnd_ioctl, NULL, 0);
}
//**************************************************************************************************
//      Удалить драйвер из системы 
//-------------------------------------------------------------------------------------------------
// !: fn: int32 drv_rnd_unplug()
//
// !: d: Удаляет драйвер ГСЧ из системы<br><br> 
//
// !: d: Возвращаемые значения:<br>
// !: d: - Стандартные коды ошибок ioctl.<br>
//***sss********************************************************************************************
int32 drv_rnd_unplug()
{
  return drv_unplug("rnd");
}

//**************************************************************************************************
//       Самоконтроль ГСЧ
//***sss********************************************************************************************
#define RANDOM_INTERVALS    (16)
#define RANDOM_VALUES       (512)
#define NL                  ((RANDOM_VALUES*2)/RANDOM_INTERVALS)
uint16 test_rnd_get_random(int32 channel)
{
  uint16  rnd_value;
  while(!RND_REDY);
  rnd_value = REG_RND_NUMBER;
  REG_RND_RESET = 0x1;
  if(channel==0) return rnd_value&0xFF;
  else return (rnd_value>>8)&0xFF;
}
int32 test_rnd_random(int32 channel)
{
  uint16 random_buf[RANDOM_VALUES];
  uint16 interv[RANDOM_INTERVALS];
  uint32 max_nl = (NL)*25;
  uint32 sum = 0;
  uint32 sum1 = 0;
    
  memset(interv, 0x0, sizeof(interv));
  for(int32 i=0; i<RANDOM_VALUES; i++)
    random_buf[i] = test_rnd_get_random(channel);

  for(int32 j=0; j<RANDOM_VALUES; j++)
  {
    interv[random_buf[j]&0xf]++;
    random_buf[j]>>=4;
    interv[random_buf[j]&0xf]++;
  }

  for(int32 i=0; i<RANDOM_INTERVALS; i++)
  {
    sum1 = interv[i]-NL;  
    sum += sum1 * sum1;
  }
  if(sum < max_nl) return OSE_OK; 
  else return OSE_DATA_TEST_ERROR;
}

